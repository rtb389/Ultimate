<script>

		var Player = 0; //checks which turn player has

		var end = false; //Variable to check if small board just ended

		var fill = []; //Array to track status of each of the 81 squares
		var over = []; //Array to check status of the 9 small boards

		//The below arrays are for use in check5
		var line = ["diagonal1", "diagonal2", "horizontal", "vertical"];
		var bool = ["true", "true", "true", "true"];
		
		/* Following functions fill parts of arrays used, to prevent 
		possible error from calling on undefined variables */

		for(var i = 0; i < 9; i++){
			fill[i] = [];
			for(var j = 0; j < 9; j++){
				fill[i][j] = "";
			}
		}
		fill[9] = -1 //Next
		fill[10] = ""//Array will fill with x or o when a player wins
		fill[11] = 0 //Tells how many turns have passed

		for(var i = 0; i < 9; i++){
			over[i] = "";
		}

		/*Following variables track how many squares in the smaller
		boards are filled, so that next can be adjusted if it goes
		to a completely filled board */

		var w = [0, 0, 0, 0, 0, 0, 0, 0, 0]; //How many times each small board has been played in
		var boxes = ["TL", "TM", "TR", "ML", "MM", "MR", "BL", "BM", "BR"];
		var wboxes = ["wTL", "wTM", "wTR", "wML", "wMM", "wMR", "wBL", "wBM", "wBR"];

		var num; //Used to track which square is being selected
		var num2; //Stores board number
		var num3; //Stores space on small board

////////////////////////////////////////////////////////////////////////////////

//Fork tells how many two-in-a-rows you have on a board (that have the third space open)
function fork(x, y){
		var num1 = 0;
		for (i = 0; i < 3; i++){
			if (y[3*i] == x && y[3*i] == y[3*i + 1] && y[3*i + 2] == ""){
				num1++;
			}
			else{
				if (y[3*i] == x && y[3*i] == y[3*i + 2] && y[3*i + 1] == ""){
					num1++;
				}
				else{
					if (y[3*i + 1] == x && y[3*i + 1] == y[3*i + 2] && y[3*i] == ""){
						num1++;
					}
				}
			}
			if (y[i] == x && y[i] == y[i + 3] && y[i + 6] == ""){
				num1++;
			}
			else{
				if (y[i] == x && y[i] == y[i + 6] && y[i + 3] == ""){
					num1++;
				}
				else{
					if (y[i + 3] == x && y[i + 3] == y[i + 6] && y[i] == ""){
						num1++;
					}
				}
			}
			if (y[0] == x && y[0] == y[4] && y[8] == ""){
					num1++;
				}
			else{
				if (y[0] == x && y[0] == y[8] && y[4] == ""){
					num1++;
				}
				else{
					if (y[4] == x && y[4] == y[8] && y[0] == ""){
						num1++;
					}
				}
			}
			if (y[2] == x && y[2] == y[4] && y[6] == ""){
					num1++;
			}
			else{
				if (y[2] == x && y[2] == y[6] && y[4] == ""){
					num1++;
				}
				else{
					if (y[4] == x && y[4] == y[6] && y[2] == ""){
						num1++;
					}
				}
			}
		}
		return num;
}

//Corner tells if you have a corner of a board
function corner(x, y){
	y[0] == x || y[2] == x || y[6] == x ||	y[8] == x
}

//Side tells if you have an edge space
function side(x, y){
	y[1] == x || y[3] == x || y[5] == x ||	y[7] == x
}

//Calculates points for a board that is not won yet
function point(z){
	var a = 0;
	var x = fork("x", z);
	var o = fork("o", z);
	if (x > 1){
		a = 5;
	}
	else{
		if (o > 1){
			a = 5;
		}
		else{
			if (x == 1){
				a = 4;
			}
			else{
				if (o == 1){
					a = -4;
				}
				else{
					if (z[4] == "x"){
						a = 3;
					}
					else{
						if (z[4] == "o"){
							a = -3;
						}
						else{
							if (corner("x", z)){
								a = 2;
							}
							else{
								if (corner("o", z)){
									a = -2;
								}
								else{
									if (side("x", z)){
										a = 1;
									}
									else{
										if (side("o", z)){
											a = -1;
										}
										else {
											a = 0;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}			
	return a;
}

//Calculates points for the entire game
function points(z){
		var b = 0
		if (z[0][10] == "x"){
			b = 100;
		}
		else{
			if (z[0][10] == "o"){
				b = -100;
			}
			else{
				b += 6 * point(z[1]);
			}
			for (i = 0; i < 9; i++){
				if (z[1][i] == ""){
					b += point(z[0][i]);
				}
			}
			if (Player == 0){
				return -b;
			}
			else{
				return b
			}
		}
}

///////////////////////////////////////////////////////////////////////////////

		//Tells how many spaces of a given board are empty
		function empty(x){
			var n = [];
			var j = 0;
			for (i = 0; i < 9; i++){
				if(x[i] == ""){
					n[j] = i;
					j++;
				}
			}
			console.log(fill)
			console.log(n)
			return n;
		}

		//Takes input of form int(number corresponding to a space on the board) and an array containing two arrays: fill and over of the current board
		function move(x, y){

			var a = y[0];
			var e = y[1];
			var b;
			if (fill[11]%2 == 0){
				b = "x";
			}
			else{
				b = "o";
			}
			a[11]++;
			var c = x%9;
			var d = Math.floor(x/9);

			a[d][c] = b;
			if(e[d] == ""){
				if(check5(c, bool, a[d])){
					e[d] = b;
					if(check5(d, bool, e)){
						a[10] = b;
					}
				}
			}
			console.log(c)
			console.log(d)
			console.log(a[c])
			console.log(e)
			if (empty(a[c]).length == 0){
				a[9] = -1;
			}
			else{
				a[9] = c;
			}

			return [a, e];
		}

		//Gives number corresponding to space that will result in the maximum guaranteed score for the player given an array x(a tree of arrays containing fill and over), an int y telling the level within the tree, and ints a and b to keep track of minimum and maximum scores
		function minimax(x, y, a, b){
			if (x[0][0][0].constructor === String)
				return points(x)
			else{
			 	if(x[0].constructor === Array){
			 		if (y%2 == 0){
			 			var c = minimax(x[0], y+1, -1000, a);
						if (c > a){
							return c;
						}
						for (i = 1; i < x.length; i++){
							var d = minimax(x[i], y+1, c, a)
							if (d > a){
								return d;
							}
							else{
								if (d > c){
									c = d;
								}
							}
						}
						return c;
					}
					else{
						var c = minimax(x[0], y+1, 1000, a)
						if (c < a){
							return c;
						}
						for (i = 1; i < x.length; i++){
							d = minimax(x[i], y+1, c, a)
							if (d < a){
								return d;
							}
							else{
						 		if(d < c){
									c = d;
								}
							}
						}
						return c
					}
				}
			}
		}
//Given an array of items (either arrays containing fill and num or arrays of these arrays), creates the next level of the tree by using move on all open spaces in the board that one is supposed to play in

function replace(a){
	var c = [];
	for (i = 0; i < a.length; i++){
		if (a[i][0][0][0].constructor === String){
			if (a[i][0][10] != ""){
				c[i] = a[i];
			}
			else{
				if (a[i][0][9] == -1){
					var d = []
					var j = 0
					for (k = 0; k < 9; k++){
						for (l = 0; l < 9; l++){
							if(a[i][0][k][l] == ""){
								d[j] = move(9*k + l, a);
								j++;
							}
						}
					}
					c[i] = d;
				}
				else {
					var d = [];
					var j = 0;
					var k = a[i][0][9];
					for (l = 0; l < 9; l++){
						if(a[i][0][k][l] == ""){
							d[j] = move(9*k + l, a);
							j++;
						}
					}
					c[i] = d;
				}
			}
		}
		else{
			if (a[i][0].constructor === Array){
				c[i] = replace(a[i]);
			}
		}
	}
	return c;
}

//Combines replace and minimax to find the optimal move
function sim(x){
	var d = [];
	if (fill[9] == -1){
		var i = 0;
		for (j = 0; j < 9; j++){
			for(k = 0; k < 9; k++){
				if (fill[j][k] == ""){
					d[i] = 9*j + k;
					i++;
				}
			}
		}
	}
	else{
		var i = 0;
		var j = fill[9];
		for(k = 0; k < 9; k++){
			if (fill[j][k] == ""){
				d[i] = 9*j + k;
				i++;
			}
		}
	}
	var e = [];
	for (i = 0; i < d.length; i++){
		e[i] = move(d[i], [fill, over]);
	}
	for (i = 0; i < x; i++){
		e = replace(e);
	}
	var j = -1000;
	var l = i;
	for (i = 0; i < e.length; i++){
		var k = minimax(e[i], 0, 1000, -1000)
		if(k > j){
			j = k;
			l = i;
		}
	}
	return d[l];
}

///////////////////////////////////////////////////////////////////////////////

		//check5 is a helper function for check3 and 4 to see if a 3x3 board is filled

		function check5(x, y, z){
			switch (x){
					case 0:
						if(z[x] == z[x+1] && z[x] == z[x+2]){
							return y[2];
						}
						else if(z[x] == z[x+3] && z[x] == z[x+6]){
							return y[3];
						}
						else if(z[x] == z[x+4] && z[x] == z[x+8]){
							return y[0];
						}
						break;
					case 1:
						if(z[x] == z[x-1] && z[x] == z[x+1]){
							return y[2];
						}
						else if(z[x] == z[x+3] && z[x] == z[x+6]){
							return y[3];
						}
						break;
					case 2:
						if(z[x] == z[x-1] && z[x] == z[x-2]){
							return y[2];
						}
						else if(z[x] == z[x+3] && z[x] == z[x+6]){
							return y[3];
						}
						else if(z[x] == z[x+2] && z[x] == z[x+4]){
							return y[1];
						}
						break;
					case 3:
						if(z[x] == z[x+1] && z[x] == z[x+2]){
							return y[2];
						}
						else if(z[x] == z[x+3] && z[x] == z[x-3]){
							return y[3];
						}
						break;
					case 4:
						if(z[x] == z[x+1] && z[x] == z[x-1]){
							return y[2];
						}
						else if(z[x] == z[x+3] && z[x] == z[x-3]){
							return y[3];
						}
						else if(z[x] == z[x+4] && z[x] == z[x-4]){
							return y[0];
						}
						else if(z[x] == z[x+2] && z[x] == z[x-2]){
							return y[1];
						}
						break;
					case 5:
						if(z[x] == z[x-1] && z[x] == z[x-2]){
							return y[2];
						}
						else if(z[x] == z[x+3] && z[x] == z[x-3]){
							return y[3];
						}
						break;
					case 6:
						if(z[x] == z[x+1] && z[x] == z[x+2]){
							return y[2];
						}
						else if(z[x] == z[x-6] && z[x] == z[x-3]){
							return y[3];
						}
						else if(z[x] == z[x-2] && z[x] == z[x-4]){
							return y[1];
						}
						break;
					case 7:
						if(z[x] == z[x+1] && z[x] == z[x-1]){
							return y[2];
						}
						else if(z[x] == z[x-6] && z[x] == z[x-3]){
							return y[3];
						}
						break;
					case 8:
						if(z[x] == z[x-2] && z[x] == z[x-1]){
							return y[2];
						}
						else if(z[x] == z[x-6] && z[x] == z[x-3]){
							return y[3];
						}
						else if(z[x] == z[x-4] && z[x] == z[x-8]){
							return y[0];
						}
						break;
			}
		}

		// check4 checks whether or not the entire board is finished
		function check4(){
			if(check5(num2, bool, over)){
				if(Player == 0){
					fill[10] = "x";
				}
				else{
					fill[10] = "o";
				}
			}
			if(fill[10] != ""){
				if(Player == 0){
					alert("WINNER: PLAYER 1");
				}
				else{
					alert("WINNER: PLAYER 2");
				}
			}
		}

		//unCheck returns which of the large boards you are in
		function unCheck(){
			return "." + wboxes[num2];
		}

		//addLine draws a line through a completed row/column/diagonal
		function addLine(){
			var x = unCheck();
			var y = check5(num3, line, fill[num2]);
			switch (y){
				case "diagonal1":
					$(x + ".TL").addClass("diagonal1");
					$(x + ".MM").addClass("diagonal1");
					$(x + ".BR").addClass("diagonal1");
					break;
				case "diagonal2":
					$(x + ".TR").addClass("diagonal2");
					$(x + ".MM").addClass("diagonal2");
					$(x + ".BL").addClass("diagonal2");
					break;
				case "horizontal":
					if(num%9 < 3){
						$(x + ".TL").addClass("horizontal");
						$(x + ".TM").addClass("horizontal");
						$(x + ".TR").addClass("horizontal");
					}
					else if(num%9 < 6){
						$(x + ".ML").addClass("horizontal");
						$(x + ".MM").addClass("horizontal");
						$(x + ".MR").addClass("horizontal");
					}
					else{
						$(x + ".BL").addClass("horizontal");
						$(x + ".BM").addClass("horizontal");
						$(x + ".BR").addClass("horizontal");
					}
					break;
				case "vertical":
					if (num%3 == 0){
						$(x + ".TL").addClass("vertical");
						$(x + ".ML").addClass("vertical");
						$(x + ".BL").addClass("vertical");
					}
					else if(num%3 == 1){
						$(x + ".TM").addClass("vertical");
						$(x + ".MM").addClass("vertical");
						$(x + ".BM").addClass("vertical");
					}
					else{
						$(x + ".TR").addClass("vertical");
						$(x + ".MR").addClass("vertical");
						$(x + ".BR").addClass("vertical");
					}
				break;
			}
		}

		// check3 checks whether or not the small board is finished and fills the over array
		function check3(){
			if(over[num2] == ""){
				end = check5(num3, bool, fill[num2]);
				if(end){
					if(Player == 0){
						over[num2] = "x";
					}
					else{
						over[num2] = "o";
					}
					end = false;
					addLine();
					check4();
				}
			}
		}

		// check2 is a helper function of check
		function check2(x){
			for (i = 0; i < 9; i++){
				if ($(x).hasClass(boxes[i])){
					num += i;
					num2 = Math.floor(num/9); 
					num3 = num%9		
					break;	
				}
			}
			if(Player == 0){
				fill[num2][num3] = "x";
			}
			else{
				fill[num2][num3] = "o";
			}
			check3();
		}

		//firstClick adds the first turn's choice to the corresponding w variable
		function firstClick(x){
			for (i = 0; i < 9; i++){
				if ($(x).hasClass(wboxes[i])){
					w[i]++;
					break;			
				}
			}
		}

		/* check finds the square selected and fills the corresponding
		element of the fill array (with the help of check2) */
		function check(x){
			for (i = 0; i < 9; i++){
				if ($(x).hasClass(wboxes[i])){
					num = 9*i;	
					break;		
				}
			}
			check2(x);	
		}

		//returnClass adds onto the w variables (for the next move) and adjusts next
		function returnClass(x){
			check(x);
			for (i = 0; i < 9; i++){
				if($(x).hasClass(boxes[i])){
					if(w[i] == 9){
						fill[9] = -1
					}
					else{
						fill[9] = i;
						w[i]++;
					}
					break;
				}
			}
			
			fill[11]++;
			if(fill[11] == 1){
				firstClick(x);
			}

//////////////////////////////////////////////////////////////////////
			//Applies AI if game is not over
			if(fill[10] == ""){
				num = sim(1);
				num2 = Math.floor(num/9);
				num3 = num%9;
				var m = move(num, [fill, over]);
				fill = m[0];
				if (Player == 0){
					$("." + wboxes[num2] + "." + boxes[num3]).text("o");
				}
				else{
					$("." + wboxes[num2] + "." + boxes[num3]).text("x");
				}
				if(over[num2] != m[1][num2]){
					addLine();
				}
				over = m[1];		
				if (fill[10] != ""){
					if (Player == 0){
						alert("WINNER: PLAYER 2");
					}
					else{
						alert("WINNER: PLAYER 1");
					}
				}
			}
//////////////////////////////////////////////////////////////////////
			
		}


$("document").ready(
	function(){
		$(".col-xs-1").hover(
			function(){
				if(fill[10] == ""){
					if(!$(this).text().trim().length){
						if(fill[9]==-1){
							$(this).css("background-color", "yellow");
						}
						else{
							if($(this).hasClass(wboxes[fill[9]])){
								$(this).css("background-color", "yellow");
							}
						}
					}
				}
			},
			function(){
				$(this).css("background-color", "white");
			}
		);
		$(".col-xs-1").click(
			function(){
				if(fill[10] == ""){
					if(!$(this).text().trim().length && Player == 0){
						if(fill[9]==-1){
							$(this).text("x");
							returnClass(this);
						}
						else{
							if($(this).hasClass(wboxes[fill[9]])){
								$(this).text("x");
								returnClass(this);
							}
						}
					}
					if(!$(this).text().trim().length && Player == 1){
						if(fill[9]==-1){
							$(this).text("o");
							returnClass(this);
						}
						else{
							if($(this).hasClass(wboxes[fill[9]])){	
								$(this).text("o");
								returnClass(this);	
							}
						}
					}
				}
			}
		);
	}
);

</script>